// https://adventofcode.com/2019/day/19
//
// --- Day 19: Tractor Beam ---
//
// Unsure of the state of Santa's ship, you borrowed the tractor beam technology from Triton. Time to test it out.
//
// When you're safely away from anything else, you activate the tractor beam, but nothing happens. It's hard to tell whether it's working if there's nothing to use it on. Fortunately, your ship's drone system can be configured to deploy a drone to specific coordinates and then check whether it's being pulled. There's even an Intcode program (your puzzle input) that gives you access to the drone system.
//
// The program uses two input instructions to request the X and Y position to which the drone should be deployed. Negative numbers are invalid and will confuse the drone; all numbers should be zero or positive.
//
// Then, the program will output whether the drone is stationary (0) or being pulled by something (1). For example, the coordinate X=0, Y=0 is directly in front of the tractor beam emitter, so the drone control program will always report 1 at that location.
//
// To better understand the tractor beam, it is important to get a good picture of the beam itself. For example, suppose you scan the 10x10 grid of points closest to the emitter:
//
//        X
//   0->      9
//  0#.........
//  |.#........
//  v..##......
//   ...###....
//   ....###...
// Y .....####.
//   ......####
//   ......####
//   .......###
//  9........##
//
// In this example, the number of points affected by the tractor beam in the 10x10 area closest to the emitter is 27.
//
// However, you'll need to scan a larger area to understand the shape of the beam. How many points are affected by the tractor beam in the 50x50 area closest to the emitter? (For each of X and Y, this will be 0 through 49.)
//
// Your puzzle answer was 209.
// --- Part Two ---
//
// You aren't sure how large Santa's ship is. You aren't even sure if you'll need to use this thing on Santa's ship, but it doesn't hurt to be prepared. You figure Santa's ship might fit in a 100x100 square.
//
// The beam gets wider as it travels away from the emitter; you'll need to be a minimum distance away to fit a square of that size into the beam fully. (Don't rotate the square; it should be aligned to the same axes as the drone grid.)
//
// For example, suppose you have the following tractor beam readings:
//
// #.......................................
// .#......................................
// ..##....................................
// ...###..................................
// ....###.................................
// .....####...............................
// ......#####.............................
// ......######............................
// .......#######..........................
// ........########........................
// .........#########......................
// ..........#########.....................
// ...........##########...................
// ...........############.................
// ............############................
// .............#############..............
// ..............##############............
// ...............###############..........
// ................###############.........
// ................#################.......
// .................########OOOOOOOOOO.....
// ..................#######OOOOOOOOOO#....
// ...................######OOOOOOOOOO###..
// ....................#####OOOOOOOOOO#####
// .....................####OOOOOOOOOO#####
// .....................####OOOOOOOOOO#####
// ......................###OOOOOOOOOO#####
// .......................##OOOOOOOOOO#####
// ........................#OOOOOOOOOO#####
// .........................OOOOOOOOOO#####
// ..........................##############
// ..........................##############
// ...........................#############
// ............................############
// .............................###########
//
// In this example, the 10x10 square closest to the emitter that fits entirely within the tractor beam has been marked O. Within it, the point closest to the emitter (the only highlighted O) is at X=25, Y=20.
//
// Find the 100x100 square closest to the emitter that fits entirely within the tractor beam; within that square, find the point closest to the emitter. What value do you get if you take that point's X coordinate, multiply it by 10000, then add the point's Y coordinate? (In the example above, this would be 250020.)
//
// Your puzzle answer was 10450905.

use std::fs;

use anyhow::Context;

use crate::prog::Prog;

type Result<T> = std::result::Result<T, anyhow::Error>;

fn main() -> Result<()> {
    let input = fs::read_to_string("input/aoc2019/day19")?;
    let nums: Vec<i64> =
        input.trim()
            .split(',')
            .map(|s| s.parse()
                .with_context(|| format!("Failed to parse {}", s)))
            .collect::<Result<_>>()?;
    // inspect(&nums);
    part1(&nums);
    part2(&nums);
    Ok(())
}

fn in_beam_area(prog: &Prog, x: i64, y: i64) -> bool {
    let mut prog_clone = prog.clone();
    prog_clone.send(x);
    prog_clone.send(y);
    prog_clone.resume().unwrap();
    match prog_clone.recv_unwrap() {
        0 => false,
        1 => true,
        _ => panic!("unrecognized output"),
    }
}

fn part1(nums: &Vec<i64>) {
    let prog = Prog::new(nums.clone());
    let count = (0..50)
        .flat_map(|y| (0..50).map(move |x| (x, y)))
        .filter(|(x, y)| in_beam_area(&prog, *x, *y))
        .count();
    println!("{}", count);
}

fn part2(nums: &Vec<i64>) {
    let prog = Prog::new(nums.clone());
    let mut x = 0;
    let mut y = 100;
    loop {
        while !in_beam_area(&prog, x, y) {
            x += 1;
        }
        if in_beam_area(&prog, x + 99, y - 99) {
            break;
        }
        y += 1;
    }
    let res = (x * 10000) + (y - 99);
    println!("{}", res);
}

// #...................................................................................................
// ....................................................................................................
// ....................................................................................................
// ....................................................................................................
// .....#..............................................................................................
// ......#.............................................................................................
// .......#............................................................................................
// ........#...........................................................................................
// .........##.........................................................................................
// ..........##........................................................................................
// ...........##.......................................................................................
// ............##......................................................................................
// .............###....................................................................................
// ..............###...................................................................................
// ...............###..................................................................................
// ................###.................................................................................
// .................####...............................................................................
// ..................####..............................................................................
// ...................####.............................................................................
// ....................#####...........................................................................
// .....................#####..........................................................................
// ......................#####.........................................................................
// .......................#####........................................................................
// ........................######......................................................................
// .........................######.....................................................................
// ...........................#####....................................................................
// ............................#####...................................................................
// .............................######.................................................................
// ..............................######................................................................
// ...............................######...............................................................
// ................................######..............................................................
// .................................#######............................................................
// ..................................#######...........................................................
// ...................................#######..........................................................
// ....................................#######.........................................................
// .....................................########.......................................................
// ......................................########......................................................
// .......................................########.....................................................
// ........................................#########...................................................
// .........................................#########..................................................
// ..........................................#########.................................................
// ...........................................#########................................................
// ............................................##########..............................................
// .............................................##########.............................................
// ..............................................##########............................................
// ...............................................##########...........................................
// ................................................###########.........................................
// .................................................###########........................................
// ..................................................###########.......................................
// ...................................................###########......................................
// .....................................................###########....................................
// ......................................................###########...................................
// .......................................................###########..................................
// ........................................................############................................
// .........................................................############...............................
// ..........................................................############..............................
// ...........................................................############.............................
// ............................................................#############...........................
// .............................................................#############..........................
// ..............................................................#############.........................
// ...............................................................#############........................
// ................................................................##############......................
// .................................................................##############.....................
// ..................................................................##############....................
// ...................................................................##############...................
// ....................................................................###############.................
// .....................................................................###############................
// ......................................................................###############...............
// .......................................................................###############..............
// ........................................................................################............
// .........................................................................################...........
// ..........................................................................################..........
// ...........................................................................#################........
// ............................................................................#################.......
// ..............................................................................################......
// ...............................................................................################.....
// ................................................................................#################...
// .................................................................................#################..
// ..................................................................................#################.
// ...................................................................................#################
// ....................................................................................################
// .....................................................................................###############
// ......................................................................................##############
// .......................................................................................#############
// ........................................................................................############
// .........................................................................................###########
// ..........................................................................................##########
// ...........................................................................................#########
// ............................................................................................########
// .............................................................................................#######
// ..............................................................................................######
// ...............................................................................................#####
// ................................................................................................####
// .................................................................................................###
// ..................................................................................................##
// ...................................................................................................#
// ....................................................................................................
// ....................................................................................................
// ....................................................................................................
// ....................................................................................................
#[allow(dead_code)]
fn inspect(nums: &Vec<i64>) {
    let prog = Prog::new(nums.clone());
    let mut grid = vec![vec![0u8; 100]; 100];

    for y in 0..100 {
        for x in 0..100 {
            grid[y as usize][x as usize] =
                if in_beam_area(&prog, x, y) {
                    b'#'
                } else {
                    b'.'
                };
        }
    }

    for line in grid.iter() {
        let s = std::str::from_utf8(line).unwrap();
        println!("{}", s);
    }
}

mod prog {
    use std::collections::vec_deque::Drain;
    use std::collections::VecDeque;
    use std::convert::TryFrom;
    use std::iter;

    use super::Result;

    #[derive(Debug)]
    pub enum Status {
        Blocked,
        Stopped,
    }

    #[derive(Debug, Clone, Eq, PartialEq, Hash)]
    pub struct Prog {
        nums: Vec<i64>,
        i: usize,
        relbase: i64,
        input: VecDeque<i64>,
        output: VecDeque<i64>,
    }

    impl Prog {
        pub fn new(nums: Vec<i64>) -> Prog {
            Prog {
                nums,
                i: 0,
                relbase: 0,
                input: VecDeque::new(),
                output: VecDeque::new(),
            }
        }

        #[allow(dead_code)]
        pub fn send_str(&mut self, s: &str) {
            for i in s.bytes().map(|c| c as i64) {
                self.send(i);
            }
        }

        #[allow(dead_code)]
        pub fn send_and_resume(&mut self, i: i64) -> Result<Status>
        {
            self.send(i);
            self.resume()
        }

        pub fn send(&mut self, i: i64) {
            self.input.push_back(i);
        }

        #[allow(dead_code)]
        pub fn recv_iter(&mut self) -> Drain<i64> {
            self.output.drain(..)
        }

        pub fn recv_unwrap(&mut self) -> i64 {
            self.output.pop_front().unwrap()
        }

        #[allow(dead_code)]
        pub fn is_empty_output(&self) -> bool {
            !self.output.is_empty()
        }

        #[allow(dead_code)]
        pub fn len_output(&self) -> usize {
            self.output.len()
        }

        pub fn resume(&mut self) -> Result<Status> {
            while self.i < self.nums.len() {
                let op = self.nums[self.i] % 100;
                if op == 99 {
                    break;
                }
                let modes = (self.nums[self.i] / 100).to_string();
                let mut modes = modes.chars().rev()
                    .map(|i| i.to_digit(10).unwrap())
                    .chain(iter::repeat(0));

                match op {
                    1 | 2 | 7 | 8 => {
                        let num1 = self.read_val(modes.next().unwrap(), self.i + 1)?;
                        let num2 = self.read_val(modes.next().unwrap(), self.i + 2)?;
                        let pos = self.read_pos(modes.next().unwrap(), self.i + 3)?;
                        self.nums[pos] = match op {
                            1 => num1 + num2,
                            2 => num1 * num2,
                            7 => if num1 < num2 { 1 } else { 0 },
                            8 => if num1 == num2 { 1 } else { 0 },
                            _ => unreachable!(),
                        };
                        self.i += 4;
                    }
                    3 => {
                        let pos = self.read_pos(modes.next().unwrap(), self.i + 1)?;
                        self.nums[pos] = match self.input.pop_front() {
                            None => return Ok(Status::Blocked),
                            Some(m) => m,
                        };
                        self.i += 2;
                    }
                    4 => {
                        let num = self.read_val(modes.next().unwrap(), self.i + 1)?;
                        self.output.push_back(num);
                        self.i += 2;
                    }
                    5 | 6 => {
                        let num = self.read_val(modes.next().unwrap(), self.i + 1)?;
                        let cond = match op {
                            5 => num != 0,
                            6 => num == 0,
                            _ => unreachable!(),
                        };
                        if cond {
                            let pos = self.read_val(modes.next().unwrap(), self.i + 2)?;
                            self.i = usize::try_from(pos)?
                        } else {
                            self.i += 3;
                        }
                    }
                    9 => {
                        let num = self.read_val(modes.next().unwrap(), self.i + 1)?;
                        self.relbase += num;
                        self.i += 2;
                    }
                    _ => anyhow::bail!("Unrecognized opcode: {}", op),
                };
                self.check_extend(self.i);
            }
            Ok(Status::Stopped)
        }

        fn read_val(&mut self, mode: u32, idx: usize) -> Result<i64> {
            let idx = match mode {
                0 => usize::try_from(self.get_raw_val(idx))?,
                1 => idx,
                2 => usize::try_from(self.get_raw_val(idx) + self.relbase)?,
                _ => anyhow::bail!("Unrecognized parameter mode: {}", mode),
            };
            Ok(self.get_raw_val(idx))
        }

        fn read_pos(&mut self, mode: u32, idx: usize) -> Result<usize> {
            let idx = match mode {
                0 => usize::try_from(self.get_raw_val(idx))?,
                2 => usize::try_from(self.get_raw_val(idx) + self.relbase)?,
                _ => anyhow::bail!("Invalid parameter mode for pos: {}", mode),
            };
            self.check_extend(idx);
            Ok(idx)
        }

        fn check_extend(&mut self, idx: usize) {
            let Prog { nums, .. } = self;
            if idx >= nums.len() {
                let extend_len = idx - nums.len() + 1;
                nums.extend(iter::repeat(0).take(extend_len));
            }
        }

        fn get_raw_val(&mut self, idx: usize) -> i64 {
            self.check_extend(idx);
            self.nums[idx]
        }
    }
}
